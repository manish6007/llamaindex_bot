from llama_index.core.agent import ReActAgent
from llama_index.core.tools import FunctionTool
from typing import Optional, Dict, Any
import logging
from llama_index.llms.bedrock_converse import BedrockConverse
from llamaIndex.memory import AgentMemory
from llama_index.embeddings.bedrock import BedrockEmbedding
import json
from llama_index.core import (
    SimpleDirectoryReader, VectorStoreIndex, Settings
)
from pydantic import BaseModel
from typing import List
import boto3
import time
from dotenv import load_dotenv
load_dotenv()

class SQLResponse(BaseModel):
    sql_query: str
    data: List[dict]
    explanation: str

def execute_sql(query: str) -> SQLResponse:
    client = boto3.client('athena', region_name='us-east-1')
    response = client.start_query_execution(
        QueryString=query,
        QueryExecutionContext={'Database': "athena_db"},
        ResultConfiguration={'OutputLocation': "s3://bedrock-350474408512-us-east-1"}
    )
    query_execution_id = response['QueryExecutionId']

    while True:
        response = client.get_query_execution(QueryExecutionId=query_execution_id)
        state = response['QueryExecution']['Status']['State']
        if state in ['SUCCEEDED', 'FAILED', 'CANCELLED']:
            break
        time.sleep(1)

    if state == 'SUCCEEDED':
        result = client.get_query_results(QueryExecutionId=query_execution_id)
        columns = [col['Name'] for col in result['ResultSet']['ResultSetMetadata']['ColumnInfo']]
        rows = result['ResultSet']['Rows'][1:]
        data = [dict(zip(columns, [item.get('VarCharValue', '') for item in row['Data']])) for row in rows]
        explanation = f"Executed query: {query}. Retrieved {len(data)} records."
        return SQLResponse(sql_query=query, data=data, explanation=explanation)
    else:
        reason = response['QueryExecution']['Status'].get('StateChangeReason', 'Unknown')
        raise Exception(f"Query failed: {reason}")

def process_query(query: str) -> str:
    """
    Processes a query using Bedrock LLM and embeddings.

    Args:
        query (str): The user's query.

    Returns:
        str: The response generated by the LLM.
    """
    # Initialize Bedrock LLM
    llm = BedrockConverse(
            model="us.anthropic.claude-3-sonnet-20240229-v1:0",
            region_name="us-east-1",
        )
    Settings.llm = llm

    # Initialize Bedrock Embedding
    embed_model = BedrockEmbedding(
        aws_access_key_id="",
        aws_secret_access_key="", # Optional, if using temporary credentials
        region_name="us-east-1",
        model_name="amazon.titan-embed-text-v1"
    )

    # Load documents
    documents = SimpleDirectoryReader(input_dir="./data").load_data()

    # Create an index
    index = VectorStoreIndex.from_documents(
        documents=documents,
        embed_model=embed_model,
        llm=llm
    )

class BedrockAgent:
    """A specialized agent for handling SQL queries with AWS Bedrock and memory management."""
    
    def __init__(self, logger: Optional[logging.Logger] = None):
        """
        Initialize the Bedrock agent with tools, memory, and context.
        
        Args:
            logger: Optional logger instance
        """
        self.logger = logger or logging.getLogger(__name__)
        self._initialize_components()
        
    def _initialize_components(self):
        """Initialize all required components for the agent."""
        # Initialize tools
        self.execute_sql_tool = FunctionTool.from_defaults(fn=execute_sql)
        self.query_gen_tool = FunctionTool.from_defaults(fn=process_query)
        
        # Initialize LLM
        self.llm = BedrockConverse(
            model="anthropic.claude-3-sonnet-20240229-v1:0",
            region_name="us-east-1",
        )
        
        # Initialize memory
        self.agent_memory = AgentMemory()
        
        # Agent context
        self.agent_context = """
        You are an expert in writing Athena ANSI SQL standard queries. You can answer database-related queries 
        compatible with AWS Athena. Use the QueryProcessor to prepare SQL queries. If the question is not 
        directly related to the database or SQL, retrieve the relevant information from your conversation memory. 
        You can also use the SQL execution tool to execute SQL queries and retrieve results. Run limit queries 
        to get sample data from the database. Use CAST in case of any type mismatch in the query. 
        Always return Final ans with below format:
        Final Answer: { "sql_query": "...", "data": [...], "explanation": "..." }
        """
        
        # Create the agent
        self.agent = ReActAgent.from_tools(
            tools=[self.execute_sql_tool, self.query_gen_tool],
            llm=self.llm,
            memory=self.agent_memory.composable_memory(),
            max_iterations=20,
            context=self.agent_context,
            verbose=True
        )
    
    def generate_response(self, user_input: str) -> Dict[str, Any]:
        """
        Generate a response for the user input with proper memory handling.
        Enforces the output format for Streamlit rendering.
        """
        try:
            # Get fresh memory reference
            current_memory = self.agent_memory.composable_memory()
            current_messages = len(current_memory.get())
            self.logger.debug(f"Memory before cleaning: {current_messages} messages remaining")

            # Generate response
            response = self.agent.chat(user_input)
            response_str = str(response)

            # Enforce output format
            sql_query = None
            data = None
            explanation = None
            if "Final Answer:" in response_str:
                try:
                    json_str = response_str.split("Final Answer:")[1].strip()
                    parsed = json.loads(json_str)
                    sql_query = parsed.get("sql_query", "")
                    data = parsed.get("data", "")
                    explanation = parsed.get("explanation", "")
                except Exception as e:
                    self.logger.warning(f"Could not parse response: {str(e)}")
            else:
                explanation = response_str

            enforced_response = {
                "sql_query": sql_query or "",
                "data": data or "",
                "explanation": explanation or ""
            }

            # Handle non-SQL queries
            cleaned = False
            if "Tell me a joke" in user_input:
                self.logger.info("Detected non-SQL query, cleaning memory")
                self.agent_memory.remove_last_n(2)
                cleaned = True
                remaining_messages = len(self.agent_memory.composable_memory().get())
                self.logger.debug(f"Memory after cleaning: {remaining_messages} messages remaining")

            return {
                "success": True,
                "response": enforced_response,
                "cleaned_memory": cleaned
            }

        except Exception as e:
            self.logger.error(f"Error generating response: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "response": "Sorry, I encountered an error processing your request"
            }
    
    def _format_response(self, response: str) -> Dict[str, Any]:
        """
        Format the agent response into a structured format.
        
        Args:
            response: Raw agent response string
            
        Returns:
            Formatted response dictionary
        """
        try:
            if "Final Answer:" in response:
                # Extract JSON part from the response
                json_str = response.split("Final Answer:")[1].strip()
                return json.loads(json_str)
            return {"raw_response": response}
        except Exception as e:
            self.logger.warning(f"Could not parse response: {str(e)}")
            return {"raw_response": response}
    
    def clear_memory(self) -> None:
        """Completely reset the agent's conversation memory."""
        self.agent_memory.clear_memory()
        self.logger.info("Agent memory cleared")